<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>http浅析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="http 浅析http的一些概述超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TC">
<meta property="og:type" content="article">
<meta property="og:title" content="http浅析">
<meta property="og:url" content="http://yoursite.com/2019/06/15/http%E6%B5%85%E6%9E%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="http 浅析http的一些概述超文本传输​​协议（HTTP）是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 TC">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mdn.mozillademos.org/files/13677/Fetching_a_page.png">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png">
<meta property="og:image" content="https://mdn.mozillademos.org/files/13771/HTTPStaleness.png">
<meta property="og:image" content="https://yqfile.alicdn.com/c49f722ce22ba69422f9f44a2e8a67c318f1d5f4.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_1440w.jpg">
<meta property="og:image" content="https://res.hualala.com/basicdoc/e1d1d51f-d4fc-492c-957a-e0eb7cf785fe.png">
<meta property="og:image" content="https://res.hualala.com/basicdoc/b16b2bb0-67d4-43f2-87fc-120e90ad276b.png">
<meta property="article:published_time" content="2019-06-15T15:07:57.000Z">
<meta property="article:modified_time" content="2020-06-26T15:43:17.301Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="http">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdn.mozillademos.org/files/13677/Fetching_a_page.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-http浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/http%E6%B5%85%E6%9E%90/" class="article-date">
  <time datetime="2019-06-15T15:07:57.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      http浅析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="http-浅析"><a href="#http-浅析" class="headerlink" title="http 浅析"></a>http 浅析</h2><h3 id="http的一些概述"><a href="#http的一些概述" class="headerlink" title="http的一些概述"></a>http的一些概述</h3><p>超文本传输​​协议（<code>HTTP</code>）是一个用于传输超媒体文档（例如 <code>HTML</code>）的应用层协议。它是为 <code>Web</code> 浏览器与 <code>Web</code> 服务器之间的通信而设计的，但也可以用于其他目的。<code>HTTP</code> 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。<code>HTTP</code> 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 <code>TCP/IP</code> 层，但可以在任何可靠的传输层上使用；也就是说，不像 <code>UDP</code>，它是一个不会静默丢失消息的协议。一个完整的请求</p>
<p><img src="https://mdn.mozillademos.org/files/13677/Fetching_a_page.png" alt="http请求的一些应用"></p>
<h4 id="http首部"><a href="#http首部" class="headerlink" title="http首部"></a>http首部</h4><p><code>HTTP</code> 消息头允许客户端和服务器通过 <code>request</code>和 <code>response</code>传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。<br>根据不同上下文，可将消息头分为：</p>
<ul>
<li><p><code>General headers</code>: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</p>
<ul>
<li>常见的有<code>Date、Cache-Control 或 Connection</code>。</li>
</ul>
</li>
<li><p><code>Request headers</code>: 包含更多有关要获取的资源或客户端本身信息的消息头。</p>
<ul>
<li>请求头是<code>HTTP</code>头的一种，它可在<code>HTTP</code>请求中使用，并且和请求主体无关 。某些请求头如 <code>Accept、Accept-*、 If-*</code>允许执行条件请求。某些请求头如：<code>Cookie, User-Agent 和 Referer</code>描述了请求本身以确保服务端能返回正确的响应</li>
</ul>
</li>
<li><p><code>Response headers</code>: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</p>
<ul>
<li>响应头<code>（Response header</code>可以定义为：被用于<code>http</code>响应中并且和响应消息主体无关的那一类 <code>HTTP header</code>。像<code>Age, Location 和 Server</code>都属于响应头，他们被用于描述响应。</li>
</ul>
</li>
<li><p><code>Entity headers</code>: 包含有关实体主体的更多信息，比如主体长(<code>Content-Length</code>)度或其<code>MIME</code>类型。</p>
<ul>
<li>实体报头<code>HTTP header</code>用来描述消息体内容。实体报头既可用于请求也可用于响应中。如<code>Content-Length，Content-Language，Content-Encoding</code>之类的报头都是实体报头<h4 id="http请求的方法"><a href="#http请求的方法" class="headerlink" title="http请求的方法"></a>http请求的方法</h4></li>
</ul>
</li>
<li><p><code>GET</code></p>
<ul>
<li><code>GET</code>方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</li>
</ul>
</li>
<li><p><code>HEAD</code></p>
<ul>
<li><code>HEAD</code>方法请求一个与GET请求的响应相同的响应，但没有响应体.</li>
</ul>
</li>
<li><p><code>POST</code></p>
<ul>
<li><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </li>
</ul>
</li>
<li><p><code>PUT</code><br>  *<code>PUT</code>方法用请求有效载荷替换目标资源的所有当前表示。</p>
</li>
<li><p><code>DELETE</code></p>
<ul>
<li><code>DELETE</code>方法删除指定的资源。</li>
</ul>
</li>
<li><p><code>CONNECT</code></p>
<ul>
<li><code>CONNECT</code>方法建立一个到由目标资源标识的服务器的隧道。</li>
</ul>
</li>
<li><p><code>OPTIONS</code></p>
<ul>
<li><code>OPTIONS</code>方法用于描述目标资源的通信选项。</li>
</ul>
</li>
<li><p><code>TRACE</code></p>
<ul>
<li><code>TRACE</code>方法沿着到目标资源的路径执行一个消息环回测试。</li>
</ul>
</li>
<li><p><code>PATCH</code></p>
<ul>
<li><code>PATCH</code>方法用于对资源应用部分修改。<h4 id="http状态返回码"><a href="#http状态返回码" class="headerlink" title="http状态返回码"></a>http状态返回码</h4></li>
</ul>
</li>
<li><p><strong>100</strong> 信息响应</p>
</li>
<li><p><strong>200</strong>: ok. 表示请求成功</p>
<ul>
<li><strong>201 Created</strong><ul>
<li>该请求已成功,并因此创建了一个新的资源.这通常是在<code>POST</code>请求,或是某些<code>PUT</code>请求之后返回的响应</li>
</ul>
</li>
<li><strong>202 Accepted</strong> <ul>
<li>请求已经接收到,但还未响应,没有结果.</li>
</ul>
</li>
<li><strong>204 No Content</strong><ul>
<li>服务器成功处理了请求,单不需要返回任何实体内容,并且希望返回更新了的元信息</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>300</strong>: 重定向</p>
<ul>
<li><strong>301 永久重定向</strong><ul>
<li>被请求的资源已永久移动到新位置,并且将来任何对此资源的引用都应该使用本响应返回的若干个<code>URL</code>之一.浏览器会用新资源地址替换掉之前老的.下次请求直接使用新的资源地址.</li>
</ul>
</li>
<li><strong>302 临时重定向</strong><ul>
<li>请求的资源在临时不同的<code>URI</code>响应请求. 浏览器会保留之前旧的地址,下次请求仍然使用旧的地址.</li>
</ul>
</li>
<li><strong>304 Not Modified</strong><ul>
<li>资源没有做改动, 可以使用缓存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>400</strong>: 客户端响应</p>
<ul>
<li><strong>400 Bad Request</strong><ul>
<li>语义有误,当前请求无法被服务器理解</li>
<li>请求参数有误</li>
</ul>
</li>
<li><strong>401 Unauthorized</strong><ul>
<li>当前请求需要用户验证</li>
</ul>
</li>
<li><strong>403 Forbidden</strong><ul>
<li>服务器已经理解请求,但是拒绝执行它</li>
</ul>
</li>
<li><strong>404 Not Found</strong><ul>
<li>请求失败,请求所希望的资源未被在服务器上发现</li>
</ul>
</li>
<li><strong>408 Request Timeout</strong></li>
<li><strong>406 Not Acceptable</strong></li>
</ul>
</li>
<li><p><strong>500 服务端响应</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong><ul>
<li>服务器遇到了不知道如何处理的情况</li>
</ul>
</li>
<li><strong>501 Not Implemented</strong><ul>
<li>此请求方法不被服务器支持且无法被处理</li>
</ul>
</li>
<li><strong>502 Bad Gateway</strong><ul>
<li>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应</li>
</ul>
</li>
<li><strong>503 Service Unavailable</strong><ul>
<li>服务器没有准备好处理请求。</li>
</ul>
</li>
<li><strong>504 Gateway Timeout</strong><ul>
<li>当服务器作为网关, 不能及时得到响应时返回此错误代码.<h4 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h4>http缓存主要分为强缓存和协商缓存. 强缓存浏览器直接使用,缓存资源. 协商缓存,会向服务端发送请求,咨询缓存是否新鲜可用.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大致流程图如下<br> <img src="https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png" alt="htt缓存"> </p>
<ul>
<li><code>Cache-Control</code><ul>
<li><code>no-store</code>: 不使用缓存</li>
<li><code>no-cache</code>: 缓存但重新验证,一般会和其他验证信息一起使用.</li>
<li><code>must-revalidate</code>: 那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用</li>
<li><code>max-age</code>: 缓存生效的时间,单位秒, 相对控制时间. 和<code>expires</code>同时存在时, 有显示使用该规则.</li>
<li><code>public</code>: 资源可以被中间代理和<code>CDN</code>缓存</li>
<li><code>private</code>:  则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</li>
</ul>
</li>
</ul>
<p><img src="https://mdn.mozillademos.org/files/13771/HTTPStaleness.png" alt="http使用缓存"></p>
<ul>
<li><p><code>Expires</code>: 以分钟为单位的绝对控制时间.</p>
</li>
<li><p>协商缓存</p>
<ul>
<li><code>ETag &amp;&amp; if-none-match &amp;&amp; if-match</code><ul>
<li><code>ETag</code>: 是响应头中返回的信息,是根据资源内容生成的一个<code>hash</code>值, 资源只要改变,该值就会变</li>
<li><code>If-None-Match</code>: 协商缓存时, 告诉服务器, <code>ETag</code>的值不一样时,返回新的资源</li>
</ul>
</li>
<li><code>if-modified-since &amp;&amp; last-modified &amp;&amp; if-unmodified-since</code><ul>
<li><code>Last-Modified</code>: 资源文件最后一次的更改时间</li>
<li><code>If-Modified-Since</code>: 告诉服务器资源更改的时间不一致时,返回新的资源</li>
</ul>
</li>
<li>在精确度上，<code>Etag</code>要优于<code>Last-Modified</code>，<code>Last-Modified</code>的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的<code>Last-Modified</code>其实并没有体现出来修改，但是<code>Etag</code>每次都会改变确保了精度在性能上，<code>Etag</code>要逊于<code>Last-Modified</code>，毕竟<code>Last-Modified</code>只需要记录时间，而<code>Etag</code>需要服务器通过法来计算出一个<code>hash</code>值。在优先级上，服务器校验优先考虑<code>Etag</code>。所以，两者互补<h4 id="http-cookie"><a href="#http-cookie" class="headerlink" title="http cookie"></a>http cookie</h4>http请求是无状态的, 因此再<code>Header</code>中引入<code>cookie</code>的概念,使记录稳定的状态信息成为可能.</li>
</ul>
</li>
<li><p><code>Cookie</code>主要使用以下三个方面</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>设置<code>Cookie</code>, 后端通过<code>Set-Cookie</code>来设置</p>
<ul>
<li><code>Set-Cookie:key=value; Expires|Max-age=xxx;Secure;Http-Only;SameSite=Strict;domain=xx;path=/</code></li>
</ul>
</li>
<li><p>前端通过<code>document.cookie</code>读写和设置<code>cookie</code></p>
</li>
<li><p><code>domain</code>表示的是<code>cookie</code>所在的域，默认为请求的地址.</p>
<ul>
<li>如网址为<code>www.jb51.net/test/test.aspx</code>，那么<code>domain</code>默认为<code>www.jb51.net</code>。而跨域访问，如域<code>A</code>为<code>t1.test.com</code>，域B为<code>t2.test.com</code>，那么在域<code>A</code>生产一个令域A和域B都能访问的<code>cookie</code>就要将该<code>cookie</code>的<code>domain</code>设置为<code>.test.com</code>；如果要在域<code>A</code>生产一个令域<code>A</code>不能访问而域<code>B</code>能访问的<code>cookie</code>就要将该<code>cookie</code>的<code>domain设置为t2.test.com。</code></li>
</ul>
</li>
<li><p><code>path</code>表示<code>cookie</code>所在的目录，<code>asp.net</code>默认为<code>/</code>，就是根目录。在同一个服务器上有目录如下：<code>/test/,/test/cd/,/test/dd/</code>，现设一个<code>cookie1</code>的<code>path为/test/</code>，<code>cookie2</code>的<code>path为/test/cd/</code>，那么<code>test</code>下的所有页面都可以访问到<code>cookie1</code>，而<code>/test/</code>和<code>/test/dd/</code>的子页面不能访问<code>cookie2</code>。这是因为<code>cookie</code>能让其<code>path</code>路径下的页面访问。</p>
</li>
<li><p>浏览器中其它的存储方式: <code>localStorage &amp;&amp; sessionStorage</code></p>
<ul>
<li><p>共同点：都是保存在浏览器端，且同源的。</p>
</li>
<li><p>区别：</p>
<ul>
<li><p><code>cookie</code>数据始终在同源的<code>http</code>请求中携带（即使不需要），即<code>cookie</code>在浏览器和服务器间来回传递。而<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
</li>
<li><p><code>cookie</code>数据还有路径<code>（path）</code>的概念，可以限制<code>cookie</code>只属于某个路径下。</p>
</li>
<li><p>存储大小限制也不同，<code>cookie</code>数据不能超过4k，同时因为每次<code>http</code>请求都会携带<code>cookie</code>，所以<code>cookie</code>只适合保存很小的数据，如会话标识。<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到<code>5M</code>或更大。</p>
</li>
<li><p>数据有效期不同:</p>
<ul>
<li><code>sessionStorage</code>：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>
<li><code>localStorage</code>：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>
<li><code>cookie</code>只在设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭。</li>
</ul>
</li>
<li><p>作用域不同:</p>
<ul>
<li><code>sessionStorage</code>不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li><code>localStorage</code> 在所有同源窗口中都是共享的；</li>
<li><code>cookie</code>也是在所有同源窗口中都是共享的。<h4 id="http-cors"><a href="#http-cors" class="headerlink" title="http cors"></a>http cors</h4>跨域资源共享<code>(CORS)</code> 是一种机制，它使用额外的 <code>HTTP</code> 头来告诉浏览器  让运行在一个 <code>origin (domain)</code> 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 <code>HTTP</code> 请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跨域资源共享标准（ <code>cross-origin sharing standard</code> ）允许在下列场景中使用跨域<code>HTTP</code>请求：</p>
<ul>
<li>前文提到的由 <code>XMLHttpRequest 或 Fetch</code>发起的跨域 <code>HTTP</code> 请求。</li>
<li><code>Web</code> 字体 (<code>CSS</code> 中通过 <code>@font-face</code> 使用跨域字体资源), 因此，网站就可以发布 <code>TrueType</code> 字体资源，并只允许已授权网站进行跨站调用。</li>
<li><code>WebGL</code> 贴图</li>
<li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code><h4 id="http-csp指令"><a href="#http-csp指令" class="headerlink" title="http csp指令"></a>http csp指令</h4><code>HTTP</code> 响应头<code>Content-Security-Policy</code>允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击<code>（Cross-Site Script）（XSS）</code>。<blockquote>
<p>语法<code>Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>default-src</code>: 为其他取指令提供备用服务<code>fetch directives</code>。</p>
</li>
<li><p><code>font-src</code>: 设置允许通过<code>@font-face</code>加载的字体源地址。</p>
</li>
<li><p><code>frame-src</code>: 设置允许通过类似<code>&lt;frame&gt;和&lt;iframe&gt;</code>标签加载的内嵌内容的源地址。</p>
</li>
<li><p><code>img-src</code>: 限制图片和图标的源地址</p>
</li>
<li><p><code>manifest-src</code>:  限制应用声明文件的源地址。</p>
</li>
<li><p><code>media-src</code>: 限制通过<code>&lt;audio&gt;、&lt;video&gt;或&lt;track&gt;</code>标签加载的媒体文件的源地址。</p>
</li>
<li><p><code>base-uri</code>: 限制在<code>DOM中&lt;base&gt;</code>元素可以使用的URL。</p>
</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p><strong>CDN</strong>的全称是<strong>Content Delivery Network</strong>, 即内容分发网络.其目的是使用户可就近取得所需内容，解决 <strong>Internet</strong>网络拥挤的状况，提高用户访问网站的响应速度。类似分布各地的物流仓储网络，<strong>CDN</strong>网络可以将源站的内容缓存到分布全球的<strong>CDN</strong>节点，根据用户的访问<strong>IP</strong>，就近连接<strong>CDN</strong>，提高网站响应速度。<br><img src="https://yqfile.alicdn.com/c49f722ce22ba69422f9f44a2e8a67c318f1d5f4.png"/></p>
<h4 id="为什么要使用CDN"><a href="#为什么要使用CDN" class="headerlink" title="为什么要使用CDN"></a>为什么要使用CDN</h4><p>从上面的流程中我们可以简单了解到源站访问的缺陷<br>需要通过情况复杂的路由链路，用户请求网页到网页最终呈现的时间太长。用户满意的网页打开时间是在2秒以下，用户能够忍受的极限等待时间是8秒，超过8秒大部分用户会选择离开网页。<br>连接质量受源站带宽限制，每增加一个用户，源站服务器就要扩充一份带宽才能满足需求，然而带宽的成本非常高<br>连接数量受服务器性能限制，所有请求都需要源站服务器处理<br>CDN通过分布式方案，通过空间换时间的方法，用冗余的空间换取时间，是典型的分布式实例。上述问题的核心就是用户和网站服务器的物理距离以及传输速度，CDN通过缓存机制简单粗暴地缩短用户和访问内容的距离，以达到加速访问的效果。</p>
<h4 id="CDN原理"><a href="#CDN原理" class="headerlink" title="CDN原理"></a>CDN原理</h4><p>CDN原理很简单，实现也非常清晰，具体做法就是将网站的内容——比如图片、文字、视频——存在不同地理位置的服务器上，称为CDN节点。<br>举例来说，某网站的主机在北京市的机房内，如网站不使用CDN，那么广东的用户访问该网站的时延就是数据包从广东到北京来回的时间。如果该网站使用了CDN，并且这家CDN在广州架设了节点，那么广东的用户去访问被缓存的内容时只要等待数据包在广东内传输的时间即可，以此达到加速的效果。 </p>
<ul>
<li><p>分发服务系统：最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标</p>
</li>
<li><p>负载均衡系统：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（<code>GSLB</code>）和本地负载均衡（<code>SLB</code>）。<code>GSLB</code>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的<code>cache</code>的物理位置。<code>SLB</code>主要负责节点内部的设备负载均衡</p>
</li>
<li><p>运营管理系统：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
</li>
<li><p>负责为用户提供内容服务的cache设备应部署在物理上的网络边缘位置，即CDN边缘层。CDN系统中负责全局性管理和 控制的设备组成中心层（二级缓存），中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站 回源（如果是流媒体，代价很大）</p>
</li>
<li><p>CDN骨干点和CDN POP点在功能上不同，中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；边缘节点又被称为POP（point of presence）节点，CDN POP点主要作为直接向用户提供服务的节点</p>
</li>
</ul>
<h3 id="http和http2的区别"><a href="#http和http2的区别" class="headerlink" title="http和http2的区别"></a>http和http2的区别</h3><p><strong>http2</strong> 相对于<strong>http1</strong>,大幅提升了<code>web性能</code>, 减少了网络延迟.主要体现再以下四个方面</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p><strong>HTTP/2</strong> 对消息头采用 <strong>HPACK</strong> 进行压缩传输，能够节省消息头占用的网络的流量。而 <strong>HTTP/1.x</strong> 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。 </p>
<ul>
<li><strong>HTTP/2</strong>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在<strong>HTTP/2</strong>的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>
<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。   <h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4>直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。图片<br><img src="https://pic4.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_1440w.jpg" alt="http2多路复用"><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。 HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。<h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4>服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。<br>http]</li>
</ul>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><p><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong><br>我们知道<code>HTTP</code>是明文传输的，就必不可免存在如下问题：</p>
<ol>
<li>重要数据被明文获取</li>
<li>通信双方可能被伪冒</li>
<li>数据被篡改<h4 id="HTTPS-加密的方式"><a href="#HTTPS-加密的方式" class="headerlink" title="HTTPS 加密的方式"></a>HTTPS 加密的方式</h4>首先先了解对称加密和非对称加密方式.</li>
</ol>
<ul>
<li>对称加密<br>需要对加密和解密使用相同密钥的加密算法。所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。<ul>
<li>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</li>
<li>缺点：对称加密，密钥管理的安全性很低，因为加密和解密都使用同一个密钥，在密钥的发送过程中，密钥可能被第三方截取，导致第三方也可以破解密文。</li>
</ul>
</li>
</ul>
<ul>
<li><p>非对称加密<br>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。<br>非对称密钥的算法强度复杂（是优点也是缺点），安全性依赖于算法与密钥。</p>
<ul>
<li>优点：安全性较高，比对称密钥安全性高很多。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。</li>
<li>缺点：由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</li>
</ul>
</li>
<li><p><code>HTTPS</code>采用的处理方式是: 结合对称加密和非对称加密俩种方式. 用非对称加密的方式来传输对称加密过程中的密钥,之后就可以采取对称加密的方式来传输数据</p>
</li>
<li><p>非对称加密的不足: 再交换公钥的过程中, 是明文传输的,如果传输的过程中被人劫持.拿到客户端的公钥. 然后中间人把自己的公钥给服务器. 服务器返回自己的公钥,又被中间人劫持. 中间人把自己的公钥给客户端. 然后客户端用中间人返回的公钥对秘钥进行加密, 发给中间人. 中间人中公钥进行解密得到秘钥.<br><img src="https://res.hualala.com/basicdoc/e1d1d51f-d4fc-492c-957a-e0eb7cf785fe.png" alt="密钥被中间人劫持">  </p>
</li>
<li><p>证书的引入<br>非对称性加密之所以不安全，是应为客户端不知道，这把公钥是不是服务器的。因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。解决这个问题的方式就是使用数字证书，具体是这样的：</p>
</li>
</ul>
<p>1、我们需要找到一个第三方机构，它是一个拥有公信力、大家都认可的认证中心，那就是数字证书认证机构(简称CA)。<br>2、服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。为了防止信息摘要被人调换，客户端还会用CA提供的私钥对信息摘要进行加密来形成数字签名。并且，最后还会把原来没Hash算法之前的个人信息以及公钥和数字签名合并在一起，形成数字证书。<br>3、当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。这样，就可以保证服务器的公钥安全着交给客户端了。<br><img src="https://res.hualala.com/basicdoc/b16b2bb0-67d4-43f2-87fc-120e90ad276b.png" alt="https加密的流程"></p>
<h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><p>尽管<code>HTTPS</code>并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但<code>HTTPS</code>仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<ul>
<li>使用<code>HTTPS</code>协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li><code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>http</code>协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li><code>HTTPS</code>是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等<code>HTTP</code>网站，采用<code>HTTPS</code>加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><p>虽然说<code>HTTPS</code>有很大的优势，但其相对来说，还是存在不足之处的：</p>
<ul>
<li><p><code>HTTPS</code>协议握手阶段比较费时，会使页面的加载时间延长近<strong>50%</strong>，增加<strong>10%</strong>到<strong>20%</strong>的耗电；</p>
</li>
<li><p><strong>HTTPS</strong>连接缓存不如<strong>HTTP</strong>高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
</li>
<li><p><strong>SSL</strong>证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
</li>
<li><p><strong>SSL</strong>证书通常需要绑定IP，不能在同一<strong>IP</strong>上绑定多个域名，<strong>IPv4</strong>资源不可能支撑这个消耗。</p>
</li>
<li><p><strong>HTTPS</strong>协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/http%E6%B5%85%E6%9E%90/" data-id="ckbhgqnd700027oqy337f1rp8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          js作用域和闭包
        
      </div>
    </a>
  
  
    <a href="/2019/06/14/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">js中this的指向</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="/tags/%E6%B7%B1%E5%85%A5js/" style="font-size: 20px;">深入js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/">浏览器中输入一个url到加载资源</a>
          </li>
        
          <li>
            <a href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/">浏览器渲染简介</a>
          </li>
        
          <li>
            <a href="/2020/06/16/js%E6%95%B0%E5%AD%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6/">js数字丢失精度</a>
          </li>
        
          <li>
            <a href="/2020/06/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A7%8D%E7%B1%BB/">js继承的种类</a>
          </li>
        
          <li>
            <a href="/2019/07/05/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">js中this的指向</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>