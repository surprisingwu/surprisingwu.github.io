<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浏览器中输入一个url到加载资源" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/" class="article-date">
  <time datetime="2020-06-19T01:44:38.000Z" itemprop="datePublished">2020-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/">浏览器中输入一个url到加载资源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="浏览器中输入一个url-回车后中间经历那些流程"><a href="#浏览器中输入一个url-回车后中间经历那些流程" class="headerlink" title="浏览器中输入一个url, 回车后中间经历那些流程?"></a>浏览器中输入一个url, 回车后中间经历那些流程?</h3><p>大致的流程主要有一下几步:</p>
<ol>
<li><strong>DNS</strong> 查询</li>
<li><strong>TCP</strong> 三次握手,建立连接</li>
<li><strong>HTTP</strong> 发送数据</li>
<li>服务端处理和响应数据</li>
<li>客户端接收数据</li>
<li><strong>TCP</strong>关闭连接.四次挥手</li>
<li>浏览器渲染</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/" data-id="ckbqooxmm0000k3qy7kmbg749" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器渲染" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/" class="article-date">
  <time datetime="2020-06-16T14:51:37.000Z" itemprop="datePublished">2020-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/">浏览器渲染简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器渲染简介"><a href="#浏览器渲染简介" class="headerlink" title="浏览器渲染简介"></a>浏览器渲染简介</h2><h4 id="浏览器工作大流程"><a href="#浏览器工作大流程" class="headerlink" title="浏览器工作大流程"></a>浏览器工作大流程</h4><p>废话少说，先来看个图：<br><img src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-768x250.jpg" alt="浏览器渲染大致流程图"></p>
<ul>
<li><p>从上面这个图中，我们可以看到那么几个事：</p>
<ul>
<li>浏览器会解析三个东西：<ul>
<li>一个是<code>HTML/SVG/XHTML</code>，事实上，<code>Webkit</code>有三个C++的类对应这三类文档。解析这三种文件会产生一个<code>DOM Tree</code>。</li>
<li><code>CSS</code>，解析<code>CSS</code>会产生<code>CSS</code>规则树。</li>
<li><code>Javascript</code>，脚本，主要是通过<code>DOM API</code>和<code>CSSOM API</code>来操作<code>DOM Tree</code>和<code>CSS Rule Tree</code>.</li>
</ul>
</li>
<li>解析完成后，浏览器引擎会通过<code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 来构造 <code>Rendering Tree</code>。注意：<ul>
<li><code>Rendering Tree</code> 渲染树并不等同于<code>DOM</code>树，因为一些像<code>Header</code>或<code>display:none</code>的东西就没必要放在渲染树中了。</li>
<li><code>CSS</code> 的 <code>Rule Tree</code>主要是为了完成匹配并把<code>CSS Rule</code>附加上<code>Rendering Tree</code>上的每个<code>Element</code>。也就是<code>DOM</code>结点。也就是所谓的<code>Frame</code>。</li>
<li>然后，计算每个<code>Frame</code>（也就是每个<code>Element</code>）的位置，这又叫<code>layout和reflow</code>过程。</li>
</ul>
</li>
<li>最后通过调用操作系统<code>Native GUI</code>的<code>API</code>绘制。</li>
</ul>
</li>
<li><p><code>DOM</code>解析<br><code>HTML的DOM Tree</code>解析如下：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段HTML会解析成这样：<br><img src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-01-300x197.jpg" alt="DOM Tree"></li>
<li>下面是另一个有SVG标签的情况。<br><img src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-02-300x235.jpg" alt="带有SVG DOM TREE"></li>
<li><code>CSS</code>解析<ul>
<li><code>CSS</code>的解析大概是下面这个样子（下面主要说的是<code>Gecko</code>也就是<code>Firefox</code>的玩法），假设我们有下面的<code>HTML</code>文档：</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">doc</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>A few quotes<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">para</span>&gt;</span></span><br><span class="line">   Franklin said that <span class="tag">&lt;<span class="name">quote</span>&gt;</span>"A penny saved is a penny earned."<span class="tag">&lt;/<span class="name">quote</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">para</span>&gt;</span></span><br><span class="line">   FDR said <span class="tag">&lt;<span class="name">quote</span>&gt;</span>"We have nothing to fear but <span class="tag">&lt;<span class="name">span</span>&gt;</span>fear itself.<span class="tag">&lt;/<span class="name">span</span>&gt;</span>"<span class="tag">&lt;/<span class="name">quote</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">para</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">doc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>* 于是`DOM Tree`是这个样子：</code></pre><p><img src="https://coolshell.cn/wp-content/uploads/2013/05/DOM-Tree-Example.jpg" alt="对应的DOM TREE"><br>    * 然后我们的CSS文档是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* rule 1 */</span> <span class="selector-tag">doc</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">text-indent</span>: <span class="number">1em</span>; &#125;</span><br><span class="line"><span class="comment">/* rule 2 */</span> <span class="selector-tag">title</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">font-size</span>: <span class="number">3em</span>;   &#125;</span><br><span class="line"><span class="comment">/* rule 3 */</span> <span class="selector-tag">para</span> &#123; <span class="attribute">display</span>: block; &#125;</span><br><span class="line"><span class="comment">/* rule 4 */</span> <span class="selector-attr">[class=<span class="string">"emph"</span>]</span> &#123; <span class="attribute">font-style</span>: italic; &#125;</span><br></pre></td></tr></table></figure>
<pre><code>* 于是我们的`CSS Rule Tree`会是这个样子：</code></pre><p><img src="https://coolshell.cn/wp-content/uploads/2013/05/CSS-Rule-Tree-Example.jpg" alt="对应的 CSS RULE TREE"></p>
<ul>
<li>注意，图中的第4条规则出现了两次，一次是独立的，一次是在规则3的子结点。所以，我们可以知道，建立<code>CSS Rule Tree</code>是需要比照着<code>DOM Tree</code>来的。<code>CSS</code>匹配<code>DOM Tree</code>主要是从右到左解析<code>CSS</code>的<code>Selector</code>，好多人以为这个事会比较快，其实并不一定。关键还看我们的<code>CSS</code>的<code>Selector</code>怎么写了。<ul>
<li>注意：<code>CSS</code>匹配<code>HTML</code>元素是一个相当复杂和有性能问题的事情。所以，你就会在<code>N</code>多地方看到很多人都告诉你，<code>DOM</code>树要小，<code>CSS</code>尽量用<code>id</code>和<code>class</code>，千万不要过渡层叠下去，……<br>通过这两个树，我们可以得到一个叫<code>Style Context Tree</code>，也就是下面这样（把<code>CSS Rule</code>结点<code>Attach</code>到<code>DOM Tree</code>上）：</li>
</ul>
</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2013/05/CSS-Content-Tree-Example.jpg" alt="Style Context Tree"></p>
<p>  所以，<code>Firefox</code>基本上来说是通过<code>CSS</code> 解析 生成 <code>CSS Rule Tree</code>，然后，通过比对<code>DOM</code>生成<code>Style Context Tree</code>，然后<code>Firefox</code>通过把<code>Style Context Tree</code>和其<code>Render Tree（Frame Tree）</code>关联上，就完成了。注意：<code>Render Tree</code>会把一些不可见的结点去除掉。<strong>而<code>Firefox</code>中所谓的<code>Frame</code>就是一个<code>DOM</code>节点，不要被其名字所迷惑了</strong>。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2013/05/Firefox-style-context-tree.png" alt="Style Contexts"><br>注：<code>Webkit</code>不像<code>Firefox</code>要用两个树来干这个，<code>Webkit</code>也有<code>Style</code>对象，它直接把这个<code>Style</code>对象存在了相应的<code>DOM</code>节点上了。</p>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><ul>
<li>渲染的流程基本上如下（黄色的四个步骤）：<ul>
<li>计算<code>CSS</code>样式</li>
<li>构建<code>Render Tree</code></li>
<li><code>Layout</code> – 定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow, z-index</code>属性 ……</li>
<li>正式开画</li>
</ul>
</li>
</ul>
<p><img src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-Skipping-1024x282.jpg" alt="大致的渲染流程"><br>注意：上图流程中有很多连接线，这表示了<code>Javascript</code>动态修改了<code>DOM</code>属性或是<code>CSS</code>属会导致重新<code>Layout</code>，有些改变不会，就是那些指到天上的箭头，比如，修改后的<code>CSS rule</code>没有被匹配到，等。<br>这里重要要说两个概念，一个是<code>Reflow</code>，另一个是<code>Repaint</code>。这两个不是一回事。</p>
<ul>
<li><p><code>Repaint</code>——重绘.屏幕的一部分要重画，比如某个<code>CSS</code>的背景色变了。但是元素的几何尺寸没有变。</p>
</li>
<li><p><code>Reflow</code>——回流.意味着元件的几何尺寸变了，我们需要重新验证并计算<code>Render Tree</code>。是<code>Render Tree</code>的一部分或全部发生了变化。这就是<code>Reflow</code>，或是<code>Layout</code>。（<code>HTML</code>使用的是<code>flow based layout</code>，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫<code>reflow</code>）<code>reflow</code> 会从<code>&lt;html&gt;</code>这个<code>root frame</code>开始递归往下，依次计算所有的结点几何尺寸和位置，在<code>reflow</code>过程中，可能会增加一些<code>frame</code>，比如一个文本字符串必需被包装起来。</p>
</li>
<li><p><code>Reflow</code>的成本比<code>Repaint</code>的成本高得多的多。<code>DOM Tree</code>里的每个节点都会有<code>reflow</code>方法，一个节点的<code>reflow</code>很有可能导致子结点，甚至父点以及同级结点的<code>reflow</code>。在一些高性能的电脑上也许还没什么，但是如果<code>reflow</code>发生在手机上，那么这个过程是非常痛苦和耗电的。<br>所以，下面这些动作有很大可能会是成本比较高的。</p>
<ul>
<li>当你增加、删除、修改<code>DOM</code>结点时，会导致<code>Reflow</code>或<code>Repaint</code></li>
<li>当你移动<code>DOM</code>的位置，或是搞个动画的时候。</li>
<li>当你修改<code>CSS</code>样式的时候。</li>
<li>当你<code>Resize</code>窗口的时候（移动端没有这个问题），或是滚动的时候。</li>
<li>当你修改网页的默认字体时。</li>
<li>注: <code>display:none</code>会触发<code>reflow</code>，而<code>visibility:hidden</code>只会触发<code>repaint</code>，因为没有发现位置变化。</li>
</ul>
</li>
<li><p>多说两句关于滚屏的事，通常来说，如果在滚屏的时候，我们的页面上的所有的像素都会跟着滚动，那么性能上没什么问题，因为我们的显卡对于这种把全屏像素往上往下移的算法是很快。但是如果你有一个<code>fixed</code>的背景图，或是有些Element不跟着滚动，有些<code>Elment</code>是动画，那么这个滚动的动作对于浏览器来说会是相当相当痛苦的一个过程。你可以看到很多这样的网页在滚动的时候性能有多差。因为滚屏也有可能会造成<code>reflow</code>。</p>
<ul>
<li>基本上来说，<code>reflow</code>有如下的几个原因：<ul>
<li><code>Initial</code>。网页初始化的时候。</li>
<li><code>Incremental</code>。一些<code>Javascript</code>在操作<code>DOM Tree</code>时。</li>
<li><code>Resize</code>。其些元件的尺寸变了。</li>
<li><code>StyleChange</code>。如果<code>CSS</code>的属性发生变化了。</li>
<li><code>Dirty</code>。几个<code>Incremental</code>的<code>reflow</code>发生在同一个<code>frame</code>的子树上。<br>好了，我们来看一个示例吧：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bstyle = <span class="built_in">document</span>.body.style; <span class="comment">// cache</span></span><br><span class="line"> </span><br><span class="line">bstyle.padding = <span class="string">"20px"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line">bstyle.border = <span class="string">"10px solid red"</span>; <span class="comment">//  再一次的 reflow 和 repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.color = <span class="string">"blue"</span>; <span class="comment">// repaint</span></span><br><span class="line">bstyle.backgroundColor = <span class="string">"#fad"</span>; <span class="comment">// repaint</span></span><br><span class="line"> </span><br><span class="line">bstyle.fontSize = <span class="string">"2em"</span>; <span class="comment">// reflow, repaint</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// new DOM element - reflow, repaint</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'dude!'</span>));</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就`</span>reflow<span class="string">`或`</span>repaint<span class="string">`一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次`</span>reflow<span class="string">`，这又叫异步`</span>reflow<span class="string">`或增量异步`</span>reflow<span class="string">`。但是有些情况浏览器是不会这么做的，比如：`</span>resize<span class="string">`窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行`</span>reflow<span class="string">`。</span></span><br><span class="line"><span class="string">但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="number">1.</span> offsetTop, offsetLeft, offsetWidth, offsetHeight</span><br><span class="line"><span class="number">2.</span> scrollTop/Left/Width/Height</span><br><span class="line"><span class="number">3.</span> clientTop/Left/Width/Height</span><br><span class="line"><span class="number">4.</span> IE中的 getComputedStyle(), 或 currentStyle</span><br></pre></td></tr></table></figure>
<p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会<code>flush</code>出去一些样式的改变，从而造成频繁的<code>reflow/repaint</code>。</p>
<ul>
<li>减少<code>reflow/repaint</code>: 下面是一些<code>Best Practices</code><ul>
<li>不要一条一条地修改<code>DOM</code>的样式。与其这样，还不如预先定义好<code>css</code>的<code>class</code>，然后修改<code>DOM</code>的<code>className</code>。</li>
</ul>
</li>
</ul>
<pre><code class="js"><span class="comment">// bad</span>
<span class="keyword">var</span> left = <span class="number">10</span>,
top = <span class="number">10</span>;
el.style.left = left + <span class="string">"px"</span>;
el.style.top  = top  + <span class="string">"px"</span>;

<span class="comment">// Good</span>
el.className += <span class="string">" theclassname"</span>;

<span class="comment">// Good</span>
el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;
</code></pre>
<ul>
<li>把<code>DOM</code>离线后修改。如：<ul>
<li>使用<code>documentFragment</code> 对象在内存里操作<code>DOM</code></li>
<li>先把<code>DOM</code>给<code>display:none(有一次reflow)</code>，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。</li>
<li><code>clone一个DOM</code>结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>
</ul>
</li>
<li>不要把<code>DOM</code>结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</li>
<li>尽可能的修改层级比较低的<code>DOM</code>。当然，改变层级比较底的<code>DOM</code>有可能会造成大面积的<code>reflow</code>，但是也可能影响范围很小。</li>
<li>为动画的<code>HTML</code>元件使用<code>fixed</code>或<code>absoult</code>的<code>position</code>，那么修改他们的<code>CSS</code>是不会<code>reflow</code>的。</li>
<li>千万不要使用<code>table</code>布局。因为可能很小的一个小改动会造成整个<code>table</code>的重新布局。</li>
</ul>
<p><code>In this manner, the user agent can begin to lay out the table once the entire first row has been received. Cells in subsequent rows do not affect column widths. Any cell that has content that overflows uses the ‘overflow’ property to determine whether to clip the overflow content.
Fixed layout, CSS 2.1 Specification
This algorithm may be inefficient since it requires the user agent to have access to all the content in the table before determining the final layout and may demand more than one pass.
Automatic layout, CSS 2.1 Specification</code><br>几个工具和几篇文章<br>有时候，你会也许会发现在<code>IE</code>下，你不知道你修改了什么东西，结果CPU一下子就上去了到100%，然后过了好几秒钟<code>repaint/reflow</code>才完成，这种事情以IE的年代时经常发生。所以，我们需要一些工具帮我们看看我们的代码里有没有什么不合适的东西。</p>
<ul>
<li><code>Chrome</code>下，<code>Google</code>的<code>SpeedTracer</code>是个非常强悍的工作让你看看你的浏览渲染的成本有多大。其实<code>Safari和Chrome</code>都可以使用开发者工具里的一个<code>Timeline</code>的东东。</li>
<li><code>Firefox</code>下这个基于<code>Firebug</code>的叫<code>Firebug Paint Events</code>的插件也不错。<br><code>* IE下你可以用一个叫</code>dynaTrace<code>的</code>IE`扩展。<br>最后，别忘了下面这几篇提高浏览器性能的文章：<ul>
<li><a href="http://code.google.com/speed/page-speed/docs/rules_intro.html" target="_blank" rel="noopener">Google – Web Performance Best Practices</a></li>
<li><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener">Yahoo – Best Practices for Speeding Up Your Web Site</a></li>
<li><a href="http://www.stevesouders.com/examples/rules.php" target="_blank" rel="noopener">Steve Souders – 14 Rules for Faster-Loading Web Sites</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/" data-id="ckbjfrgtn000062l4122gf0om" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js数字丢失精度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/16/js%E6%95%B0%E5%AD%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6/" class="article-date">
  <time datetime="2020-06-16T05:03:42.000Z" itemprop="datePublished">2020-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/16/js%E6%95%B0%E5%AD%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6/">js数字丢失精度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JavaScript数字精度丢失问题总结"><a href="#JavaScript数字精度丢失问题总结" class="headerlink" title="JavaScript数字精度丢失问题总结"></a>JavaScript数字精度丢失问题总结</h2><p>本文分为三个部分</p>
<ol>
<li>JS 数字精度丢失的一些典型问题</li>
<li>JS 数字精度丢失的原因</li>
<li>解决方案（一个对象+一个函数）</li>
</ol>
<h4 id="JS数字精度丢失的一些典型问题"><a href="#JS数字精度丢失的一些典型问题" class="headerlink" title="JS数字精度丢失的一些典型问题"></a>JS数字精度丢失的一些典型问题</h4><ul>
<li>两个简单的浮点数相加</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> != <span class="number">0.3</span> <span class="comment">// true`</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Chrome</code>控制台模拟对应的小数运算.<br><img src="https://res.hualala.com/basicdoc/442e7b3f-8430-4604-ba8f-b04e68cbd078.png" alt="小数相加丢失精度"></p>
</li>
<li><p>看看<code>Java</code>的运算结果<br><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106170748524-1081159205.png" alt="java 进行浮点数运算时,也是如此"></p>
</li>
<li><p>再看看Python<br><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106170830461-1451288842.png" alt="主要是机制的问题"></p>
</li>
</ul>
<ul>
<li>大整数运算</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9999999999999999</span> == <span class="number">10000000000000001</span> <span class="comment">// ？</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Chrome</code>控制台输出对应的结果</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106170956227-1489805455.png" alt="大数超出js表示的最大值时,也会丢失精度"></p>
<ul>
<li><p>16位和17位数竟然相等，没天理啊。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">9007199254740992</span></span><br><span class="line">x + <span class="number">1</span> == x <span class="comment">// ？</span></span><br></pre></td></tr></table></figure>
<p>看结果<br><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151107173235774-1370728577.png" alt="大数进行运算时,丢失精度"><br>三观又被颠覆了。</p>
</li>
</ul>
<ul>
<li>toFixed 不会四舍五入（Chrome）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.335</span>.toFixed(<span class="number">2</span>) <span class="comment">// 1.33</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Chrome</code>输出对应的结果</li>
</ul>
</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106171323805-1404560600.png" alt="小数没有四舍五入"></p>
<h4 id="JS-数字丢失精度的原因"><a href="#JS-数字丢失精度的原因" class="headerlink" title="JS 数字丢失精度的原因"></a>JS 数字丢失精度的原因</h4><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。如图<br><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106171603555-975142832.png" alt="双精度 64位存储"></p>
<ul>
<li><p>意义</p>
<ul>
<li>1位用来表示符号位</li>
<li>11位用来表示指数</li>
<li>52位表示尾数</li>
</ul>
</li>
<li><p>浮点数，比如</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> &gt;&gt; <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>…（<span class="number">1001</span>无限循环）</span><br><span class="line"><span class="number">0.2</span> &gt;&gt; <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>…（<span class="number">0011</span>无限循环）</span><br></pre></td></tr></table></figure>
<p>此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p>
<p>大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。<br>大于 9007199254740992 的可能会丢失精度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span>     &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.000</span> <span class="comment">// 共计 53 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.001</span> <span class="comment">// 中间 52 个 0</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.010</span> <span class="comment">// 中间 51 个 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> <span class="comment">// 未丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">3</span> <span class="comment">// 丢失</span></span><br><span class="line"><span class="number">9007199254740992</span> + <span class="number">4</span> <span class="comment">// 未丢失</span></span><br></pre></td></tr></table></figure>

<ul>
<li>结果如图<br><img src="https://images2015.cnblogs.com/blog/114013/201511/114013-20151106171828539-620146369.png" alt="大数进行运算时，chrome模拟的结果"></li>
</ul>
<p>以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在“舍去”，精度丢失就发生了。<br>想了解更深入的分析可以看这篇论文（又长又臭）：<a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="noopener">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。<br>对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.1 + 0.2 </span></span><br><span class="line">(<span class="number">0.1</span>*<span class="number">10</span> + <span class="number">0.2</span>*<span class="number">10</span>) / <span class="number">10</span> == <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>　　<br>以下是我写了一个对象，对小数的加减乘除运算丢失精度做了屏蔽。当然转换后的整数依然不能超过 9007199254740992。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们知道计算机编程语言里浮点数计算会存在精度丢失问题（或称舍入误差），其根本原因是二进制和实现位数限制有些数无法有限表示</span></span><br><span class="line"><span class="comment"> * 以下是十进制小数对应的二进制表示</span></span><br><span class="line"><span class="comment"> *      0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</span></span><br><span class="line"><span class="comment"> *      0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</span></span><br><span class="line"><span class="comment"> * 计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** method **</span></span><br><span class="line"><span class="comment"> *  add / subtract / multiply /divide</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ** explame **</span></span><br><span class="line"><span class="comment"> *  0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）</span></span><br><span class="line"><span class="comment"> *  0.2 + 0.4 == 0.6000000000000001  （多了 0.0000000000001）</span></span><br><span class="line"><span class="comment"> *  19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * floatObj.add(0.1, 0.2) &gt;&gt; 0.3</span></span><br><span class="line"><span class="comment"> * floatObj.multiply(19.9, 100) &gt;&gt; 1990</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> floatObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断obj是否为一个整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(obj) === obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100</span></span><br><span class="line"><span class="comment">     * @param floatNum &#123;number&#125; 小数</span></span><br><span class="line"><span class="comment">     * @return &#123;object&#125;</span></span><br><span class="line"><span class="comment">     *   &#123;times:100, num: 314&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toInteger</span>(<span class="params">floatNum</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = &#123;<span class="attr">times</span>: <span class="number">1</span>, <span class="attr">num</span>: <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">var</span> isNegative = floatNum &lt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (isInteger(floatNum)) &#123;</span><br><span class="line">            ret.num = floatNum</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> strfi  = floatNum + <span class="string">''</span></span><br><span class="line">        <span class="keyword">var</span> dotPos = strfi.indexOf(<span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">var</span> len    = strfi.substr(dotPos+<span class="number">1</span>).length</span><br><span class="line">        <span class="keyword">var</span> times  = <span class="built_in">Math</span>.pow(<span class="number">10</span>, len)</span><br><span class="line">        <span class="keyword">var</span> intNum = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(floatNum) * times + <span class="number">0.5</span>, <span class="number">10</span>)</span><br><span class="line">        ret.times  = times</span><br><span class="line">        <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">            intNum = -intNum</span><br><span class="line">        &#125;</span><br><span class="line">        ret.num = intNum</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 核心方法，实现加减乘除运算，确保不丢失精度</span></span><br><span class="line"><span class="comment">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a &#123;number&#125; 运算数1</span></span><br><span class="line"><span class="comment">     * @param b &#123;number&#125; 运算数2</span></span><br><span class="line"><span class="comment">     * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数</span></span><br><span class="line"><span class="comment">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params">a, b, digits, op</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> o1 = toInteger(a)</span><br><span class="line">        <span class="keyword">var</span> o2 = toInteger(b)</span><br><span class="line">        <span class="keyword">var</span> n1 = o1.num</span><br><span class="line">        <span class="keyword">var</span> n2 = o2.num</span><br><span class="line">        <span class="keyword">var</span> t1 = o1.times</span><br><span class="line">        <span class="keyword">var</span> t2 = o2.times</span><br><span class="line">        <span class="keyword">var</span> max = t1 &gt; t2 ? t1 : t2</span><br><span class="line">        <span class="keyword">var</span> result = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></span><br><span class="line">                    result = n1 + n2</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></span><br><span class="line">                    result = n1 + n2 * (t1 / t2)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></span><br><span class="line">                    result = n1 * (t2 / t1) + n2</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'subtract'</span>:</span><br><span class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</span><br><span class="line">                    result = n1 - n2</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</span><br><span class="line">                    result = n1 - n2 * (t1 / t2)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = n1 * (t2 / t1) - n2</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result / max</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'multiply'</span>:</span><br><span class="line">                result = (n1 * n2) / (t1 * t2)</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'divide'</span>:</span><br><span class="line">                result = (n1 / n2) * (t2 / t1)</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加减乘除的四个接口</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'add'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'subtract'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'multiply'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, digits</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'divide'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exports</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add,</span><br><span class="line">        subtract: subtract,</span><br><span class="line">        multiply: multiply,</span><br><span class="line">        divide: divide</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>toFixed</code>的修复如下</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toFixed 修复</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">num, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, s)</span><br><span class="line">    <span class="keyword">var</span> des = num * times + <span class="number">0.5</span></span><br><span class="line">    des = <span class="built_in">parseInt</span>(des, <span class="number">10</span>) / times</span><br><span class="line">    <span class="keyword">return</span> des + <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/16/js%E6%95%B0%E5%AD%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6/" data-id="ckbhgqnd000007oqy6vjn1ze5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js继承的种类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A7%8D%E7%B1%BB/" class="article-date">
  <time datetime="2020-06-13T10:04:54.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A7%8D%E7%B1%BB/">js继承的种类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JS-继承"><a href="#JS-继承" class="headerlink" title="JS 继承"></a>JS 继承</h2><p>许多<strong>OO</strong>语言中都支持俩种继承方式: 接口继承和实现继承.接口继承只继承方法签名,而实现继承则继承实际的方法. 由于<code>JS</code>中的函数没有签名,因此在<code>ECMAScript</code>中无法实现接口继承. <code>ECMAScript</code>只支持实现继承,而且依靠原型链来实现</p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><ul>
<li>核心思想: 子类的原型指向父类的实例</li>
<li>缺点: <ul>
<li>所有的实例共享原型中的引用类型</li>
<li>不能像父类的构造函数传参</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>,<span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getColorsLength = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.colors.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super()</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Sub(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.colors) <span class="comment">// ['red', 'blue']</span></span><br></pre></td></tr></table></figure>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><ul>
<li>核心思路: 借用父类的构造函数<br>优点: 解决了共享引用类型的问题</li>
<li>缺点<ul>
<li>共享的方法都要写在父类的构造函数中</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Sub(<span class="string">'Nike'</span>, <span class="number">18</span>)</span><br><span class="line">instance.sayName() <span class="comment">// My name is Nike</span></span><br></pre></td></tr></table></figure>

<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><ul>
<li>借用构造函数和原型链继承的组合</li>
<li>优点<ul>
<li>解决了共享引用类型和传参的问题</li>
</ul>
</li>
<li>缺点<ul>
<li>调用俩次父类</li>
<li>原型上属性重复</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Sub(<span class="string">'Nike'</span>, <span class="number">18</span>)</span><br><span class="line">instance.sayName()</span><br></pre></td></tr></table></figure>
<h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><ul>
<li>借助原型, 根据已有的对象创建对象</li>
<li>使用<code>ES5</code>提供的<code>Object.create(obj, descriptorObj)</code>也可以实现该效果</li>
<li>优点<ul>
<li>根据已有的对象创建对象<br>缺点:<ul>
<li>共享引用类型</li>
<li>不能传参</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Nike'</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = create(obj)</span><br><span class="line">a.sayName()</span><br></pre></td></tr></table></figure>

<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><ul>
<li>封装继承的过程, 并以某种方式增强对象</li>
<li>能够复用执行对象的方法和属性, 并对其增强</li>
<li>缺点<ul>
<li>没法传参</li>
<li>增强的方法或属性没法复用</li>
<li>共享引用类型</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(o)</span><br><span class="line">    o.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hi!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'Nike'</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = create(obj)</span><br><span class="line">a.sayName()</span><br><span class="line">a.sayHi()</span><br></pre></td></tr></table></figure>
<h4 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h4><ul>
<li>原型继承和寄生式继承的组合</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subCons, superCons</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prototype = <span class="built_in">Object</span>.create(superCons.prototype)</span><br><span class="line">    prototype.constructor = superCons</span><br><span class="line">    subCons.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Sub, Super)</span><br><span class="line"></span><br><span class="line">Sub.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My age is <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><ul>
<li><strong>es6</strong>新增类继承</li>
<li>缺点: <ul>
<li>不能共享属性</li>
<li>属性和方法重名时, 属性会屏蔽方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Sub(</span><br><span class="line">instance.sayName()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h4><ul>
<li><code>JavaScript</code>高级程序设计</li>
<li>深入理解<code>ES6</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A7%8D%E7%B1%BB/" data-id="ckbep6x1s0005xfl4cgav8oq5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js事件循环" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/05/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2019-07-05T02:05:12.000Z" itemprop="datePublished">2019-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/05/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">js中this的指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/05/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/" data-id="ckbhgqnd500017oqy6nx26cjx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js作用域和闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/" class="article-date">
  <time datetime="2019-06-30T11:00:02.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/">js作用域和闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/30/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/" data-id="ckbep6x1o0002xfl4d7bkfexk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http浅析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/http%E6%B5%85%E6%9E%90/" class="article-date">
  <time datetime="2019-06-15T15:07:57.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/15/http%E6%B5%85%E6%9E%90/">http浅析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="http-浅析"><a href="#http-浅析" class="headerlink" title="http 浅析"></a>http 浅析</h2><h3 id="http的一些概述"><a href="#http的一些概述" class="headerlink" title="http的一些概述"></a>http的一些概述</h3><p>超文本传输​​协议（<code>HTTP</code>）是一个用于传输超媒体文档（例如 <code>HTML</code>）的应用层协议。它是为 <code>Web</code> 浏览器与 <code>Web</code> 服务器之间的通信而设计的，但也可以用于其他目的。<code>HTTP</code> 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。<code>HTTP</code> 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于 <code>TCP/IP</code> 层，但可以在任何可靠的传输层上使用；也就是说，不像 <code>UDP</code>，它是一个不会静默丢失消息的协议。一个完整的请求</p>
<p><img src="https://mdn.mozillademos.org/files/13677/Fetching_a_page.png" alt="http请求的一些应用"></p>
<h4 id="http首部"><a href="#http首部" class="headerlink" title="http首部"></a>http首部</h4><p><code>HTTP</code> 消息头允许客户端和服务器通过 <code>request</code>和 <code>response</code>传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。<br>根据不同上下文，可将消息头分为：</p>
<ul>
<li><p><code>General headers</code>: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</p>
<ul>
<li>常见的有<code>Date、Cache-Control 或 Connection</code>。</li>
</ul>
</li>
<li><p><code>Request headers</code>: 包含更多有关要获取的资源或客户端本身信息的消息头。</p>
<ul>
<li>请求头是<code>HTTP</code>头的一种，它可在<code>HTTP</code>请求中使用，并且和请求主体无关 。某些请求头如 <code>Accept、Accept-*、 If-*</code>允许执行条件请求。某些请求头如：<code>Cookie, User-Agent 和 Referer</code>描述了请求本身以确保服务端能返回正确的响应</li>
</ul>
</li>
<li><p><code>Response headers</code>: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</p>
<ul>
<li>响应头<code>（Response header</code>可以定义为：被用于<code>http</code>响应中并且和响应消息主体无关的那一类 <code>HTTP header</code>。像<code>Age, Location 和 Server</code>都属于响应头，他们被用于描述响应。</li>
</ul>
</li>
<li><p><code>Entity headers</code>: 包含有关实体主体的更多信息，比如主体长(<code>Content-Length</code>)度或其<code>MIME</code>类型。</p>
<ul>
<li>实体报头<code>HTTP header</code>用来描述消息体内容。实体报头既可用于请求也可用于响应中。如<code>Content-Length，Content-Language，Content-Encoding</code>之类的报头都是实体报头<h4 id="http请求的方法"><a href="#http请求的方法" class="headerlink" title="http请求的方法"></a>http请求的方法</h4></li>
</ul>
</li>
<li><p><code>GET</code></p>
<ul>
<li><code>GET</code>方法请求一个指定资源的表示形式. 使用GET的请求应该只被用于获取数据.</li>
</ul>
</li>
<li><p><code>HEAD</code></p>
<ul>
<li><code>HEAD</code>方法请求一个与GET请求的响应相同的响应，但没有响应体.</li>
</ul>
</li>
<li><p><code>POST</code></p>
<ul>
<li><code>POST</code>方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用. </li>
</ul>
</li>
<li><p><code>PUT</code><br>  *<code>PUT</code>方法用请求有效载荷替换目标资源的所有当前表示。</p>
</li>
<li><p><code>DELETE</code></p>
<ul>
<li><code>DELETE</code>方法删除指定的资源。</li>
</ul>
</li>
<li><p><code>CONNECT</code></p>
<ul>
<li><code>CONNECT</code>方法建立一个到由目标资源标识的服务器的隧道。</li>
</ul>
</li>
<li><p><code>OPTIONS</code></p>
<ul>
<li><code>OPTIONS</code>方法用于描述目标资源的通信选项。</li>
</ul>
</li>
<li><p><code>TRACE</code></p>
<ul>
<li><code>TRACE</code>方法沿着到目标资源的路径执行一个消息环回测试。</li>
</ul>
</li>
<li><p><code>PATCH</code></p>
<ul>
<li><code>PATCH</code>方法用于对资源应用部分修改。<h4 id="http状态返回码"><a href="#http状态返回码" class="headerlink" title="http状态返回码"></a>http状态返回码</h4></li>
</ul>
</li>
<li><p><strong>100</strong> 信息响应</p>
</li>
<li><p><strong>200</strong>: ok. 表示请求成功</p>
<ul>
<li><strong>201 Created</strong><ul>
<li>该请求已成功,并因此创建了一个新的资源.这通常是在<code>POST</code>请求,或是某些<code>PUT</code>请求之后返回的响应</li>
</ul>
</li>
<li><strong>202 Accepted</strong> <ul>
<li>请求已经接收到,但还未响应,没有结果.</li>
</ul>
</li>
<li><strong>204 No Content</strong><ul>
<li>服务器成功处理了请求,单不需要返回任何实体内容,并且希望返回更新了的元信息</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>300</strong>: 重定向</p>
<ul>
<li><strong>301 永久重定向</strong><ul>
<li>被请求的资源已永久移动到新位置,并且将来任何对此资源的引用都应该使用本响应返回的若干个<code>URL</code>之一.浏览器会用新资源地址替换掉之前老的.下次请求直接使用新的资源地址.</li>
</ul>
</li>
<li><strong>302 临时重定向</strong><ul>
<li>请求的资源在临时不同的<code>URI</code>响应请求. 浏览器会保留之前旧的地址,下次请求仍然使用旧的地址.</li>
</ul>
</li>
<li><strong>304 Not Modified</strong><ul>
<li>资源没有做改动, 可以使用缓存</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>400</strong>: 客户端响应</p>
<ul>
<li><strong>400 Bad Request</strong><ul>
<li>语义有误,当前请求无法被服务器理解</li>
<li>请求参数有误</li>
</ul>
</li>
<li><strong>401 Unauthorized</strong><ul>
<li>当前请求需要用户验证</li>
</ul>
</li>
<li><strong>403 Forbidden</strong><ul>
<li>服务器已经理解请求,但是拒绝执行它</li>
</ul>
</li>
<li><strong>404 Not Found</strong><ul>
<li>请求失败,请求所希望的资源未被在服务器上发现</li>
</ul>
</li>
<li><strong>408 Request Timeout</strong></li>
<li><strong>406 Not Acceptable</strong></li>
</ul>
</li>
<li><p><strong>500 服务端响应</strong></p>
<ul>
<li><strong>500 Internal Server Error</strong><ul>
<li>服务器遇到了不知道如何处理的情况</li>
</ul>
</li>
<li><strong>501 Not Implemented</strong><ul>
<li>此请求方法不被服务器支持且无法被处理</li>
</ul>
</li>
<li><strong>502 Bad Gateway</strong><ul>
<li>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应</li>
</ul>
</li>
<li><strong>503 Service Unavailable</strong><ul>
<li>服务器没有准备好处理请求。</li>
</ul>
</li>
<li><strong>504 Gateway Timeout</strong><ul>
<li>当服务器作为网关, 不能及时得到响应时返回此错误代码.<h4 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h4>http缓存主要分为强缓存和协商缓存. 强缓存浏览器直接使用,缓存资源. 协商缓存,会向服务端发送请求,咨询缓存是否新鲜可用.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大致流程图如下<br> <img src="https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png" alt="htt缓存"> </p>
<ul>
<li><code>Cache-Control</code><ul>
<li><code>no-store</code>: 不使用缓存</li>
<li><code>no-cache</code>: 缓存但重新验证,一般会和其他验证信息一起使用.</li>
<li><code>must-revalidate</code>: 那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用</li>
<li><code>max-age</code>: 缓存生效的时间,单位秒, 相对控制时间. 和<code>expires</code>同时存在时, 有显示使用该规则.</li>
<li><code>public</code>: 资源可以被中间代理和<code>CDN</code>缓存</li>
<li><code>private</code>:  则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。</li>
</ul>
</li>
</ul>
<p><img src="https://mdn.mozillademos.org/files/13771/HTTPStaleness.png" alt="http使用缓存"></p>
<ul>
<li><p><code>Expires</code>: 以分钟为单位的绝对控制时间.</p>
</li>
<li><p>协商缓存</p>
<ul>
<li><code>ETag &amp;&amp; if-none-match &amp;&amp; if-match</code><ul>
<li><code>ETag</code>: 是响应头中返回的信息,是根据资源内容生成的一个<code>hash</code>值, 资源只要改变,该值就会变</li>
<li><code>If-None-Match</code>: 协商缓存时, 告诉服务器, <code>ETag</code>的值不一样时,返回新的资源</li>
</ul>
</li>
<li><code>if-modified-since &amp;&amp; last-modified &amp;&amp; if-unmodified-since</code><ul>
<li><code>Last-Modified</code>: 资源文件最后一次的更改时间</li>
<li><code>If-Modified-Since</code>: 告诉服务器资源更改的时间不一致时,返回新的资源</li>
</ul>
</li>
<li>在精确度上，<code>Etag</code>要优于<code>Last-Modified</code>，<code>Last-Modified</code>的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的<code>Last-Modified</code>其实并没有体现出来修改，但是<code>Etag</code>每次都会改变确保了精度在性能上，<code>Etag</code>要逊于<code>Last-Modified</code>，毕竟<code>Last-Modified</code>只需要记录时间，而<code>Etag</code>需要服务器通过法来计算出一个<code>hash</code>值。在优先级上，服务器校验优先考虑<code>Etag</code>。所以，两者互补<h4 id="http-cookie"><a href="#http-cookie" class="headerlink" title="http cookie"></a>http cookie</h4>http请求是无状态的, 因此再<code>Header</code>中引入<code>cookie</code>的概念,使记录稳定的状态信息成为可能.</li>
</ul>
</li>
<li><p><code>Cookie</code>主要使用以下三个方面</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
</li>
<li><p>设置<code>Cookie</code>, 后端通过<code>Set-Cookie</code>来设置</p>
<ul>
<li><code>Set-Cookie:key=value; Expires|Max-age=xxx;Secure;Http-Only;SameSite=Strict;domain=xx;path=/</code></li>
</ul>
</li>
<li><p>前端通过<code>document.cookie</code>读写和设置<code>cookie</code></p>
</li>
<li><p><code>domain</code>表示的是<code>cookie</code>所在的域，默认为请求的地址.</p>
<ul>
<li>如网址为<code>www.jb51.net/test/test.aspx</code>，那么<code>domain</code>默认为<code>www.jb51.net</code>。而跨域访问，如域<code>A</code>为<code>t1.test.com</code>，域B为<code>t2.test.com</code>，那么在域<code>A</code>生产一个令域A和域B都能访问的<code>cookie</code>就要将该<code>cookie</code>的<code>domain</code>设置为<code>.test.com</code>；如果要在域<code>A</code>生产一个令域<code>A</code>不能访问而域<code>B</code>能访问的<code>cookie</code>就要将该<code>cookie</code>的<code>domain设置为t2.test.com。</code></li>
</ul>
</li>
<li><p><code>path</code>表示<code>cookie</code>所在的目录，<code>asp.net</code>默认为<code>/</code>，就是根目录。在同一个服务器上有目录如下：<code>/test/,/test/cd/,/test/dd/</code>，现设一个<code>cookie1</code>的<code>path为/test/</code>，<code>cookie2</code>的<code>path为/test/cd/</code>，那么<code>test</code>下的所有页面都可以访问到<code>cookie1</code>，而<code>/test/</code>和<code>/test/dd/</code>的子页面不能访问<code>cookie2</code>。这是因为<code>cookie</code>能让其<code>path</code>路径下的页面访问。</p>
</li>
<li><p>浏览器中其它的存储方式: <code>localStorage &amp;&amp; sessionStorage</code></p>
<ul>
<li><p>共同点：都是保存在浏览器端，且同源的。</p>
</li>
<li><p>区别：</p>
<ul>
<li><p><code>cookie</code>数据始终在同源的<code>http</code>请求中携带（即使不需要），即<code>cookie</code>在浏览器和服务器间来回传递。而<code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</p>
</li>
<li><p><code>cookie</code>数据还有路径<code>（path）</code>的概念，可以限制<code>cookie</code>只属于某个路径下。</p>
</li>
<li><p>存储大小限制也不同，<code>cookie</code>数据不能超过4k，同时因为每次<code>http</code>请求都会携带<code>cookie</code>，所以<code>cookie</code>只适合保存很小的数据，如会话标识。<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到<code>5M</code>或更大。</p>
</li>
<li><p>数据有效期不同:</p>
<ul>
<li><code>sessionStorage</code>：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li>
<li><code>localStorage</code>：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li>
<li><code>cookie</code>只在设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭。</li>
</ul>
</li>
<li><p>作用域不同:</p>
<ul>
<li><code>sessionStorage</code>不在不同的浏览器窗口中共享，即使是同一个页面；</li>
<li><code>localStorage</code> 在所有同源窗口中都是共享的；</li>
<li><code>cookie</code>也是在所有同源窗口中都是共享的。<h4 id="http-cors"><a href="#http-cors" class="headerlink" title="http cors"></a>http cors</h4>跨域资源共享<code>(CORS)</code> 是一种机制，它使用额外的 <code>HTTP</code> 头来告诉浏览器  让运行在一个 <code>origin (domain)</code> 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 <code>HTTP</code> 请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>跨域资源共享标准（ <code>cross-origin sharing standard</code> ）允许在下列场景中使用跨域<code>HTTP</code>请求：</p>
<ul>
<li>前文提到的由 <code>XMLHttpRequest 或 Fetch</code>发起的跨域 <code>HTTP</code> 请求。</li>
<li><code>Web</code> 字体 (<code>CSS</code> 中通过 <code>@font-face</code> 使用跨域字体资源), 因此，网站就可以发布 <code>TrueType</code> 字体资源，并只允许已授权网站进行跨站调用。</li>
<li><code>WebGL</code> 贴图</li>
<li>使用 <code>drawImage</code> 将 <code>Images/video</code> 画面绘制到 <code>canvas</code><h4 id="http-csp指令"><a href="#http-csp指令" class="headerlink" title="http csp指令"></a>http csp指令</h4><code>HTTP</code> 响应头<code>Content-Security-Policy</code>允许站点管理者控制用户代理能够为指定的页面加载哪些资源。除了少数例外情况，设置的政策主要涉及指定服务器的源和脚本结束点。这将帮助防止跨站脚本攻击<code>（Cross-Site Script）（XSS）</code>。<blockquote>
<p>语法<code>Content-Security-Policy: &lt;policy-directive&gt;; &lt;policy-directive&gt;</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>default-src</code>: 为其他取指令提供备用服务<code>fetch directives</code>。</p>
</li>
<li><p><code>font-src</code>: 设置允许通过<code>@font-face</code>加载的字体源地址。</p>
</li>
<li><p><code>frame-src</code>: 设置允许通过类似<code>&lt;frame&gt;和&lt;iframe&gt;</code>标签加载的内嵌内容的源地址。</p>
</li>
<li><p><code>img-src</code>: 限制图片和图标的源地址</p>
</li>
<li><p><code>manifest-src</code>:  限制应用声明文件的源地址。</p>
</li>
<li><p><code>media-src</code>: 限制通过<code>&lt;audio&gt;、&lt;video&gt;或&lt;track&gt;</code>标签加载的媒体文件的源地址。</p>
</li>
<li><p><code>base-uri</code>: 限制在<code>DOM中&lt;base&gt;</code>元素可以使用的URL。</p>
</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p><strong>CDN</strong>的全称是<strong>Content Delivery Network</strong>, 即内容分发网络.其目的是使用户可就近取得所需内容，解决 <strong>Internet</strong>网络拥挤的状况，提高用户访问网站的响应速度。类似分布各地的物流仓储网络，<strong>CDN</strong>网络可以将源站的内容缓存到分布全球的<strong>CDN</strong>节点，根据用户的访问<strong>IP</strong>，就近连接<strong>CDN</strong>，提高网站响应速度。<br><img src="https://yqfile.alicdn.com/c49f722ce22ba69422f9f44a2e8a67c318f1d5f4.png"/></p>
<h4 id="为什么要使用CDN"><a href="#为什么要使用CDN" class="headerlink" title="为什么要使用CDN"></a>为什么要使用CDN</h4><p>从上面的流程中我们可以简单了解到源站访问的缺陷<br>需要通过情况复杂的路由链路，用户请求网页到网页最终呈现的时间太长。用户满意的网页打开时间是在2秒以下，用户能够忍受的极限等待时间是8秒，超过8秒大部分用户会选择离开网页。<br>连接质量受源站带宽限制，每增加一个用户，源站服务器就要扩充一份带宽才能满足需求，然而带宽的成本非常高<br>连接数量受服务器性能限制，所有请求都需要源站服务器处理<br>CDN通过分布式方案，通过空间换时间的方法，用冗余的空间换取时间，是典型的分布式实例。上述问题的核心就是用户和网站服务器的物理距离以及传输速度，CDN通过缓存机制简单粗暴地缩短用户和访问内容的距离，以达到加速访问的效果。</p>
<h4 id="CDN原理"><a href="#CDN原理" class="headerlink" title="CDN原理"></a>CDN原理</h4><p>CDN原理很简单，实现也非常清晰，具体做法就是将网站的内容——比如图片、文字、视频——存在不同地理位置的服务器上，称为CDN节点。<br>举例来说，某网站的主机在北京市的机房内，如网站不使用CDN，那么广东的用户访问该网站的时延就是数据包从广东到北京来回的时间。如果该网站使用了CDN，并且这家CDN在广州架设了节点，那么广东的用户去访问被缓存的内容时只要等待数据包在广东内传输的时间即可，以此达到加速的效果。 </p>
<ul>
<li><p>分发服务系统：最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用 户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡 量一个CDN系统服务能力的最基本的指标</p>
</li>
<li><p>负载均衡系统：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（<code>GSLB</code>）和本地负载均衡（<code>SLB</code>）。<code>GSLB</code>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的<code>cache</code>的物理位置。<code>SLB</code>主要负责节点内部的设备负载均衡</p>
</li>
<li><p>运营管理系统：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
</li>
<li><p>负责为用户提供内容服务的cache设备应部署在物理上的网络边缘位置，即CDN边缘层。CDN系统中负责全局性管理和 控制的设备组成中心层（二级缓存），中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站 回源（如果是流媒体，代价很大）</p>
</li>
<li><p>CDN骨干点和CDN POP点在功能上不同，中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；边缘节点又被称为POP（point of presence）节点，CDN POP点主要作为直接向用户提供服务的节点</p>
</li>
</ul>
<h3 id="http和http2的区别"><a href="#http和http2的区别" class="headerlink" title="http和http2的区别"></a>http和http2的区别</h3><p><strong>http2</strong> 相对于<strong>http1</strong>,大幅提升了<code>web性能</code>, 减少了网络延迟.主要体现再以下四个方面</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p><strong>HTTP/2</strong> 对消息头采用 <strong>HPACK</strong> 进行压缩传输，能够节省消息头占用的网络的流量。而 <strong>HTTP/1.x</strong> 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。 </p>
<ul>
<li><strong>HTTP/2</strong>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在<strong>HTTP/2</strong>的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>
<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。   <h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4>直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。图片<br><img src="https://pic4.zhimg.com/80/b1e608ddb7493608efea3e76912aabe1_1440w.jpg" alt="http2多路复用"><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。 HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。<h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4>服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。<br>http]</li>
</ul>
<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><p><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong><br>我们知道<code>HTTP</code>是明文传输的，就必不可免存在如下问题：</p>
<ol>
<li>重要数据被明文获取</li>
<li>通信双方可能被伪冒</li>
<li>数据被篡改<h4 id="HTTPS-加密的方式"><a href="#HTTPS-加密的方式" class="headerlink" title="HTTPS 加密的方式"></a>HTTPS 加密的方式</h4>首先先了解对称加密和非对称加密方式.</li>
</ol>
<ul>
<li>对称加密<br>需要对加密和解密使用相同密钥的加密算法。所谓对称，就是采用这种加密方法的双方使用方式用同样的密钥进行加密和解密。密钥是控制加密及解密过程的指令。算法是一组规则，规定如何进行加密和解密。<ul>
<li>优点：对称加密算法的优点是算法公开、计算量小、加密速度快、加密效率高。</li>
<li>缺点：对称加密，密钥管理的安全性很低，因为加密和解密都使用同一个密钥，在密钥的发送过程中，密钥可能被第三方截取，导致第三方也可以破解密文。</li>
</ul>
</li>
</ul>
<ul>
<li><p>非对称加密<br>非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。<br>非对称密钥的算法强度复杂（是优点也是缺点），安全性依赖于算法与密钥。</p>
<ul>
<li>优点：安全性较高，比对称密钥安全性高很多。 非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。</li>
<li>缺点：由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</li>
</ul>
</li>
<li><p><code>HTTPS</code>采用的处理方式是: 结合对称加密和非对称加密俩种方式. 用非对称加密的方式来传输对称加密过程中的密钥,之后就可以采取对称加密的方式来传输数据</p>
</li>
<li><p>非对称加密的不足: 再交换公钥的过程中, 是明文传输的,如果传输的过程中被人劫持.拿到客户端的公钥. 然后中间人把自己的公钥给服务器. 服务器返回自己的公钥,又被中间人劫持. 中间人把自己的公钥给客户端. 然后客户端用中间人返回的公钥对秘钥进行加密, 发给中间人. 中间人中公钥进行解密得到秘钥.<br><img src="https://res.hualala.com/basicdoc/e1d1d51f-d4fc-492c-957a-e0eb7cf785fe.png" alt="密钥被中间人劫持">  </p>
</li>
<li><p>证书的引入<br>非对称性加密之所以不安全，是应为客户端不知道，这把公钥是不是服务器的。因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。解决这个问题的方式就是使用数字证书，具体是这样的：</p>
</li>
</ul>
<p>1、我们需要找到一个第三方机构，它是一个拥有公信力、大家都认可的认证中心，那就是数字证书认证机构(简称CA)。<br>2、服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要。为了防止信息摘要被人调换，客户端还会用CA提供的私钥对信息摘要进行加密来形成数字签名。并且，最后还会把原来没Hash算法之前的个人信息以及公钥和数字签名合并在一起，形成数字证书。<br>3、当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。这样，就可以保证服务器的公钥安全着交给客户端了。<br><img src="https://res.hualala.com/basicdoc/b16b2bb0-67d4-43f2-87fc-120e90ad276b.png" alt="https加密的流程"></p>
<h4 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h4><p>尽管<code>HTTPS</code>并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但<code>HTTPS</code>仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<ul>
<li>使用<code>HTTPS</code>协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li><code>HTTPS</code>协议是由<code>SSL+HTTP</code>协议构建的可进行加密传输、身份认证的网络协议，要比<code>http</code>协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li><code>HTTPS</code>是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等<code>HTTP</code>网站，采用<code>HTTPS</code>加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<h4 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h4><p>虽然说<code>HTTPS</code>有很大的优势，但其相对来说，还是存在不足之处的：</p>
<ul>
<li><p><code>HTTPS</code>协议握手阶段比较费时，会使页面的加载时间延长近<strong>50%</strong>，增加<strong>10%</strong>到<strong>20%</strong>的耗电；</p>
</li>
<li><p><strong>HTTPS</strong>连接缓存不如<strong>HTTP</strong>高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
</li>
<li><p><strong>SSL</strong>证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
</li>
<li><p><strong>SSL</strong>证书通常需要绑定IP，不能在同一<strong>IP</strong>上绑定多个域名，<strong>IPv4</strong>资源不可能支撑这个消耗。</p>
</li>
<li><p><strong>HTTPS</strong>协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/http%E6%B5%85%E6%9E%90/" data-id="ckbhgqnd700027oqy337f1rp8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/" rel="tag">http</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js中this的指向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/14/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/" class="article-date">
  <time datetime="2019-06-14T06:17:51.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/">js中this的指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/14/js%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/" data-id="ckbep6x1m0001xfl4ahmv2x6h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2019-06-01T06:18:28.000Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">js类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js-类型转换"><a href="#js-类型转换" class="headerlink" title="js 类型转换"></a>js 类型转换</h2><p>这里主要分为显示类型转换和隐式类型转换. 显示类型转换, 很简单. 主要是隐式类型转换,如果不清楚, 可能会造成代码逻辑未能达到预期结果.显式类型转换还是隐式类型转换,俩者之间的边界可能不一. 这里把显式的调用方法对数据进行转换,认为是显式转换.</p>
<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><h4 id="转化为数字"><a href="#转化为数字" class="headerlink" title="转化为数字"></a>转化为数字</h4><ul>
<li>通过<code>Number(type)</code>或其它方式把其它类型数据转化为数字.<ul>
<li>字符串转数字<ul>
<li>字符串类型的数字,可以转为对应的<strong>数字</strong>. 空字符串转化为数字为<strong>0</strong></li>
<li>字符串中含有非数字类型的. 转化为字符串为<code>NaN</code></li>
</ul>
</li>
<li>布尔值转化为数字<ul>
<li><code>true</code>: 转化为数字为<strong>1</strong></li>
<li><code>false</code>: 转化为数字为<strong>0</strong></li>
</ul>
</li>
<li><code>null</code>: 转化为数字为<strong>0</strong></li>
<li><code>undefined</code>: 转化为数字为<strong>NaN</strong></li>
<li><code>object</code>: <ul>
<li>对象会先转成对应的基础类型. 在转化成字数字</li>
</ul>
</li>
<li>解析数字字符串: 下面的俩个方法主要针对,数字类型的字符串, 传入其它数据类型, 会隐式的转化为字符串, 在解析. 因此, 在使用的时候, 避免传入其它的数据类型<ul>
<li><code>parseInt</code>: 主要解析数字字符串的整数部分.使用的时候最好带上第二个参数,不然会根据传入的第一个字符,自动判定解析规则.</li>
<li><code>parseFloat</code>: 可以解析带有小数的数字字符串</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'122'</span>)  <span class="comment">// 122</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">23</span>]) <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'45'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">// 45</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1234.34sdff'</span>, <span class="number">10</span>) <span class="comment">// 1234</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'af12323'</span>, <span class="number">10</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([], <span class="number">10</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="转化为字符串"><a href="#转化为字符串" class="headerlink" title="转化为字符串"></a>转化为字符串</h4><ul>
<li>显示的通过方法<code>String(type)</code>或其它方法把其它类型的数据转化为字符串</li>
<li>基本类型转化为字符串比较简单</li>
<li>对象转化为字符串, 会调用自身的或者原型上的<code>toString()</code>方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(&#123;&#125;)  <span class="comment">// '[object Object]'</span></span><br><span class="line">Strign(&#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;) <span class="comment">// '11'</span></span><br><span class="line"><span class="built_in">String</span>([]) <span class="comment">// ''</span></span><br></pre></td></tr></table></figure>
<h4 id="转化为布尔值"><a href="#转化为布尔值" class="headerlink" title="转化为布尔值"></a>转化为布尔值</h4></li>
<li>显示的通过<code>Boolean(type)</code>把其它类型转化为布尔值</li>
<li>转化为<code>boolean</code>为假值的有<ul>
<li><code>&#39;&#39;</code>: 空字符串</li>
<li><code>+0,-0, 0, NaN</code></li>
<li><code>null和undefine</code></li>
<li><code>false</code></li>
</ul>
</li>
<li>其它类型转化为<code>boolean</code>为真值</li>
</ul>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换, 发生的场景很多.比如对象和基本类型进行比较时,亦或者某些方法的参数. 这里举一个隐式转换的例子: <code>[]+{}和{}+[]</code></p>
<h4 id="字符串和数字之间的隐式类型转换"><a href="#字符串和数字之间的隐式类型转换" class="headerlink" title="字符串和数字之间的隐式类型转换"></a>字符串和数字之间的隐式类型转换</h4><ul>
<li>整体比较简单,尤其是在运算和字符串拼接的时候.比较多</li>
<li>如<code>&#39;234&#39;+45</code>结果是23445, <code>45+&#39;23&#39;</code>结果为68</li>
</ul>
<h4 id="其它类型转化为布尔值"><a href="#其它类型转化为布尔值" class="headerlink" title="其它类型转化为布尔值"></a>其它类型转化为布尔值</h4><ul>
<li><p><code>if(...)</code>语句中的条件判断表达式</p>
</li>
<li><p><code>for(..;..;..)</code>语句中的条件判断表达式(第二个)</p>
</li>
<li><p><code>while(..)和do..while(..)</code>循环中的条件判断表达式</p>
</li>
<li><p><code>? :</code>中的条件判断表达式</p>
</li>
<li><p>逻辑运算符 <strong>||</strong>和 <strong>&amp;&amp;</strong>左边的操作数(作为条件判断表达式)</p>
</li>
<li><p>上面的使用场景,非布尔值会被隐式强制类型转换为布尔值</p>
<h4 id="宽松相等和严格相等"><a href="#宽松相等和严格相等" class="headerlink" title="宽松相等和严格相等"></a>宽松相等和严格相等</h4><p>宽松相等俩边的数据类型不一致时,会发生隐式转换.如果对隐式转换不是特别清楚的话, 最好使用严格相等,来比较数据.</p>
</li>
<li><p><strong>===</strong> 严格相等, 会判断俩边的数据类型和大小, 比较简单</p>
</li>
<li><p><strong>==</strong> 分为俩种情况</p>
<ul>
<li>俩边的数据类型一致时, 和严格相等一样</li>
<li>俩边的数据类型不一样时, 会发生隐式转换. <ul>
<li>数字和字符串比较, 字符串会转成数字,再进行比较</li>
<li>其它类型和布尔类型进行比较, 俩者会转成数字进行比较</li>
<li><code>null 和 undefined</code>比较, 俩者相等</li>
<li>对象和数字或者字符串比较, 对象会转成基础类型,再进行比较<ul>
<li>对象<code>ToPrimitive</code>过程, 是通过调用自身的<code>toString 或者 valueOf</code>来实现的, 如果调用这俩个函数后, 还是不能返回基础类型, 就会抛出错误</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">-0</span> == +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">45</span> == <span class="string">'45'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它类型和布尔值进行比较</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125; <span class="comment">// false, &#123;&#125; 转化成数字为NaN</span></span><br><span class="line"><span class="literal">true</span> == &#123;&#125; <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">'0'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 和undefined 比较</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象和数字或者字符串比较</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line">[] == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">12</span>] == <span class="string">'12'</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">23</span>] == <span class="string">'1223'</span> <span class="comment">// false</span></span><br><span class="line">&#123;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; == <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="一些函数的参数"><a href="#一些函数的参数" class="headerlink" title="一些函数的参数"></a>一些函数的参数</h4><p>一些函数的参数, 只接受指定类型的参数. 如<code>bind, apply, call</code>等接收的第一个参数是对象, 如果传入基本类型,则会转成对应的包装类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">typeof</span> <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.bind(<span class="number">1</span>) ()  <span class="comment">// [Number, 1]  object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// [object Number]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.apply(<span class="number">2</span>) <span class="comment">// [object Number]</span></span><br></pre></td></tr></table></figure>


<h4 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h4><ul>
<li>你不知道的<code>javascript</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/01/js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" data-id="ckbep6x1r0004xfl45v6ygx51" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/" rel="tag">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%85%A5js/" rel="tag">深入js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 15px;">浏览器</a> <a href="/tags/%E6%B7%B1%E5%85%A5js/" style="font-size: 20px;">深入js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E5%88%B0%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90/">浏览器中输入一个url到加载资源</a>
          </li>
        
          <li>
            <a href="/2020/06/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/">浏览器渲染简介</a>
          </li>
        
          <li>
            <a href="/2020/06/16/js%E6%95%B0%E5%AD%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6/">js数字丢失精度</a>
          </li>
        
          <li>
            <a href="/2020/06/13/js%E7%BB%A7%E6%89%BF%E7%9A%84%E7%A7%8D%E7%B1%BB/">js继承的种类</a>
          </li>
        
          <li>
            <a href="/2019/07/05/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">js中this的指向</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>